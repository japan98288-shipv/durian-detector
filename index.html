<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Leaf Scan AI (Speed Optimized)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    
    <style>
        body { font-family: sans-serif; }
        .video-container {
            position: relative;
            display: inline-block;
            overflow: hidden; 
            width: 100%; 
        }
        #videoElement {
            width: 100%; 
            height: auto;
            display: block;
            /* ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤ (‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏î‡πâ‡∏ß‡∏¢ JS ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á) */
            transform: scaleX(-1);
        }
        #canvasOverlay {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none; 
            /* ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ Canvas (‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏î‡πâ‡∏ß‡∏¢ JS ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á) */
            transform: scaleX(-1);
        }
    </style>
</head>
<body class="bg-light">
    <nav class="navbar navbar-expand-lg navbar-dark bg-success fixed-top shadow-lg">
        <div class="container-fluid">
            <a class="navbar-brand fw-bold" href="#">Intelligent LeafScanner</a>
            
            <button id="cameraSwitchButton" class="btn btn-sm btn-outline-light" type="button" style="display: none;">
                <i class="bi bi-camera-switch fs-4"></i>
            </button>
            </div>
    </nav>
    
    <div style="height: 60px;"></div> 

    <div class="container mt-4">
        <div id="camera_section">
            <h1 class="text-center mb-4 text-success fw-bold">‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÇ‡∏£‡∏Ñ‡πÉ‡∏ö‡∏û‡∏∑‡∏ä</h1>
            
            <div class="card shadow-lg mx-auto" style="max-width: 640px;">
                <div class="card-body p-0"> 
                    <div class="video-container" id="video-wrapper">
                        <video id="videoElement" autoplay playsinline></video>
                        <canvas id="canvasOverlay"></canvas>
                    </div>
                </div>
                
                <div class="card-footer text-center p-3 bg-white">
                    <button id="startButton" class="btn btn-primary btn-lg w-100 shadow-sm">
                        <i class="bi bi-camera-video"></i> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö
                    </button>
                    <p id="status" class="mt-3 fs-6 fw-bold text-info">‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°...</p>
                    <p id="connectionStatus" class="mt-2 fs-6 fw-bold text-danger">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API: ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö...</p> 
                    <p id="detectionCount" class="text-muted small">‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö: 0</p>
                </div>
            </div>
        </div>
        
        <div id="results_history" class="container mt-5 p-4 border rounded bg-white shadow-sm">
            <h2 class="text-primary"><i class="bi bi-list-columns"></i> ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</h2>
            <p class="text-muted">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ</p>
        </div>
    </div> 
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>

    <script>
    
    // *** ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ API ***
    const BASE_API_URL = "https://tawanna-ionogenic-gyrally.ngrok-free.dev"; 
    const API_URL = `${BASE_API_URL}/detect_disease`; 
    
    const AI_INPUT_SIZE = 480; 
    
    // üéØ Mapping ‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏≤‡∏™‡∏†‡∏≤‡∏©‡∏≤‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏£‡∏Ñ‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏à‡πâ‡∏á‡∏°‡∏≤)
    const CLASS_NAME_MAPPING = {
        'agal-spot': '‡πÉ‡∏ö‡∏à‡∏∏‡∏î (Agal Spot)',       
        'blight leaf': '‡πÉ‡∏ö‡πÑ‡∏´‡∏°‡πâ (Blight Leaf)',   
        'healthy': '‡πÉ‡∏ö‡∏õ‡∏Å‡∏ï‡∏¥/‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏£‡∏Ñ',           
    };

    // Element References
    const video = document.getElementById('videoElement');
    const canvas = document.getElementById('canvasOverlay');
    const videoWrapper = document.getElementById('video-wrapper');
    const startButton = document.getElementById('startButton');
    const cameraSwitchButton = document.getElementById('cameraSwitchButton'); // üõ†Ô∏è NEW
    const statusElement = document.getElementById('status');
    const detectionCountElement = document.getElementById('detectionCount');
    const connectionStatusElement = document.getElementById('connectionStatus');
    const historySection = document.getElementById('results_history');
    const ctx = canvas.getContext('2d');
    
    // Global State Variables
    let stream = null;
    let isProcessing = false;
    let isBackendConnected = false;
    let currentFacingMode = 'environment'; // üõ†Ô∏è NEW: ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô: ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏á
    
    let latestDetectionData = { 
        boxes: [], 
        detections: 0 
    }; 

    // üí° ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡πá‡∏ô 600ms ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á Ngrok Rate Limit (100 ‡∏Ñ‡∏≥‡∏Ç‡∏≠/‡∏ô‡∏≤‡∏ó‡∏µ)
    let frameSendInterval = 600; 
    let lastSendTime = 0; 

    // ----------------------------------------------------------------------
    // ** 1. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å: Loop ‡∏Å‡∏≤‡∏£ Render 60 FPS **
    // ----------------------------------------------------------------------
    function drawLoop() {
        if (!isProcessing) return; 
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoundingBoxes(latestDetectionData.boxes); 

        const now = performance.now();
        if (now - lastSendTime >= frameSendInterval) {
            sendFrame(now); 
            lastSendTime = now;
        }

        requestAnimationFrame(drawLoop);
    }

    // ----------------------------------------------------------------------
    // ** 2. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á Bounding Boxes **
    // ----------------------------------------------------------------------
    function drawBoundingBoxes(boxes) {
        if (!boxes || boxes.length === 0) return;

        const scaleX = canvas.width / AI_INPUT_SIZE;
        const scaleY = canvas.height / AI_INPUT_SIZE;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ‡∏à‡∏≤‡∏Å CSS 
        const isMirroredCSS = currentFacingMode === 'user'; 

        ctx.lineWidth = 3; 
        ctx.font = 'bold 16px Arial'; 
        ctx.textAlign = 'start';
        ctx.strokeStyle = '#dc3545';
        ctx.fillStyle = '#dc3545'; 

        boxes.forEach(detection => {
            const [x1_ai, y1_ai, x2_ai, y2_ai] = detection.box; 
            const conf = detection.confidence;
            const englishName = detection.class;
            
            let x1 = x1_ai * scaleX;
            const y1 = y1_ai * scaleY;
            const width = (x2_ai - x1_ai) * scaleX;
            const height = (y2_ai - y1_ai) * scaleY;

            // ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á X ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á
            if (isMirroredCSS) {
                x1 = canvas.width - (x1 + width);
            }
            
            ctx.strokeRect(x1, y1, width, height); 
            
            const thaiName = CLASS_NAME_MAPPING[englishName.toLowerCase()] || englishName;
            const label = `${thaiName} (${(conf * 100).toFixed(0)}%)`; 
            
            const textWidth = ctx.measureText(label).width;
            ctx.fillRect(x1 - 1, y1 - 20, textWidth + 8, 20);
            
            ctx.fillStyle = 'white';
            ctx.fillText(label, x1 + 3, y1 - 5);
            ctx.fillStyle = '#dc3545'; 
        });
    }

    // ----------------------------------------------------------------------
    // ** 3. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå **
    // ----------------------------------------------------------------------
    function updateHistory(boxes) {
        let historyHtml = '<h2 class="text-primary"><i class="bi bi-list-columns"></i> ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</h2>';
        
        if (boxes.length === 0) {
            historyHtml += '<p class="text-muted">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ</p>';
        } else {
            historyHtml += '<ul class="list-group">';
            
            const uniqueDetections = new Set();
            
            boxes.forEach(detection => {
                const englishName = detection.class;
                const confidence = detection.confidence;
                
                const thaiName = CLASS_NAME_MAPPING[englishName.toLowerCase()] || englishName;
                
                if (!uniqueDetections.has(thaiName)) {
                    const confidenceColor = confidence > 0.75 ? 'text-success' : confidence > 0.5 ? 'text-warning' : 'text-muted';
                    
                    historyHtml += `
                        <li class="list-group-item d-flex justify-content-between align-items-center">
                            <span class="fw-bold">‡∏û‡∏ö: ${thaiName}</span>
                            <span class="${confidenceColor} small">
                                ‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à ${(confidence * 100).toFixed(1)}%
                            </span>
                        </li>
                    `;
                    uniqueDetections.add(thaiName);
                }
            });
            
            historyHtml += '</ul>';
        }
        
        historySection.innerHTML = historyHtml;
    }

    // ----------------------------------------------------------------------
    // ** 4. ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á **
    // ----------------------------------------------------------------------
    
    async function checkBackendConnectivity() {
        // ... (‡πÇ‡∏Ñ‡πâ‡∏î checkBackendConnectivity ‡πÄ‡∏î‡∏¥‡∏°) ...
        try {
            connectionStatusElement.textContent = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API: ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö...";
            connectionStatusElement.classList.remove('text-success', 'text-danger');
            connectionStatusElement.classList.add('text-warning');

            const response = await fetch(BASE_API_URL, { method: 'GET' });

            if (response.ok || response.status === 404 || response.status === 405) {
                isBackendConnected = true;
                connectionStatusElement.textContent = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API: ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå)";
                connectionStatusElement.classList.remove('text-warning', 'text-danger');
                connectionStatusElement.classList.add('text-success');
                return true;
            } else {
                throw new Error(`Server responded with status: ${response.status}`);
            }

        } catch (error) {
            isBackendConnected = false;
            connectionStatusElement.textContent = `‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API: ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß! (${error.message})`;
            connectionStatusElement.classList.remove('text-warning', 'text-success');
            connectionStatusElement.classList.add('text-danger');
            statusElement.textContent = "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Backend ‡πÑ‡∏î‡πâ";
            console.error("Backend Connection Check Failed:", error);
            return false;
        }
    }

    // üõ†Ô∏è NEW: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠/Canvas
    function setCameraFlip(facingMode) {
        if (facingMode === 'user') {
            // ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤: ‡∏ü‡∏•‡∏¥‡∏õ video ‡πÅ‡∏•‡∏∞ canvas ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏£‡∏∞‡∏à‡∏Å
            video.style.transform = 'scaleX(-1)';
            canvas.style.transform = 'scaleX(-1)';
        } else {
            // ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏á/‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô: ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ü‡∏•‡∏¥‡∏õ
            video.style.transform = 'none';
            canvas.style.transform = 'none';
        }
    }
    
    async function initializeCamera(constraints) {
        // ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            video.srcObject = null;
        }
        try {
            const currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            return currentStream;
        } catch (err) {
            console.warn(`Camera init failed with constraint: ${JSON.stringify(constraints)}`, err.name);
            return null;
        }
    }
    
    function setupVideoAndStartLoop(currentStream, facingMode) {
        return new Promise((resolve) => {
            stream = currentStream;
            video.srcObject = stream;

            video.load(); 

            video.onloadedmetadata = () => {
                video.play();
                
                // üõ†Ô∏è NEW: ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠/Canvas
                setCameraFlip(facingMode); 

                // 1. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏ô‡∏≤‡∏î '‡πÄ‡∏ä‡∏¥‡∏á‡∏Å‡∏≤‡∏¢‡∏†‡∏≤‡∏û' (Physical Size) ‡∏Ç‡∏≠‡∏á Canvas
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // 2. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏ô‡∏≤‡∏î '‡πÄ‡∏ä‡∏¥‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•' (CSS Size) ‡∏Ç‡∏≠‡∏á Canvas ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                const videoRect = video.getBoundingClientRect();
                canvas.style.width = `${videoRect.width}px`;
                canvas.style.height = `${videoRect.height}px`;
                
                // 3. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á Container
                videoWrapper.style.height = `${videoRect.height}px`; 
                
                console.log(`Camera Stream Ready: ${canvas.width}x${canvas.height} | CSS: ${videoRect.width}px x ${videoRect.height}px`);

                statusElement.textContent = `‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (${facingMode === 'user' ? '‡∏´‡∏ô‡πâ‡∏≤' : '‡∏´‡∏•‡∏±‡∏á'}) ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö...`;
                startButton.textContent = "‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö";
                startButton.classList.remove('btn-primary');
                startButton.classList.add('btn-danger');
                cameraSwitchButton.style.display = 'block'; // ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á

                isProcessing = true;
                drawLoop(); 
                
                startButton.onclick = stopDetection;
                resolve();
            };
        });
    }

    async function startCamera(facingMode = currentFacingMode) {
        if (!isBackendConnected) {
            statusElement.textContent = "‡∏´‡∏¢‡∏∏‡∏î! Backend ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô";
            return false;
        }

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            statusElement.textContent = "‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö MediaDevices API";
            return false;
        }
        
        currentFacingMode = facingMode;
        statusElement.textContent = `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏•‡πâ‡∏≠‡∏á (${facingMode === 'user' ? '‡∏´‡∏ô‡πâ‡∏≤' : '‡∏´‡∏•‡∏±‡∏á'})...`;

        const constraints = {
            video: {
                facingMode: facingMode
            }
        };
        
        let successfulStream = await initializeCamera(constraints);

        if (successfulStream) {
            await setupVideoAndStartLoop(successfulStream, facingMode);
            return true;
        } else {
            statusElement.textContent = `‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á (${facingMode}) ‡πÑ‡∏î‡πâ`;
            startButton.textContent = "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö (‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î)";
            cameraSwitchButton.style.display = 'none'; // ‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏ñ‡πâ‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
            return false;
        }
    }

    function stopDetection() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            video.srcObject = null;
        }
        isProcessing = false;
        statusElement.textContent = "‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß";
        startButton.textContent = "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö";
        startButton.classList.remove('btn-danger');
        startButton.classList.add('btn-primary');
        startButton.onclick = startDetectionProcess; 
        cameraSwitchButton.style.display = 'none'; // ‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        latestDetectionData = { boxes: [], detections: 0 }; 
        updateHistory([]); // ‡∏•‡πâ‡∏≤‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î
        setCameraFlip('default'); // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ
    }

    // üõ†Ô∏è NEW: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á
    async function switchCamera() {
        if (isProcessing) {
            stopDetection();
            // ‡∏™‡∏•‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î: 'environment' -> 'user' ‡∏´‡∏£‡∏∑‡∏≠ 'user' -> 'environment'
            currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
            await startDetectionProcess();
        } else {
            // ‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏¥‡πà‡∏° ‡πÅ‡∏ï‡πà‡∏Å‡∏î‡∏™‡∏•‡∏±‡∏ö ‡∏Å‡πá‡∏™‡∏•‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î‡πÑ‡∏ß‡πâ‡∏£‡∏≠
            currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
        }
    }

    async function sendFrame(sendTime) {
        if (!isProcessing || video.paused || video.ended) {
            return;
        }

        try {
            const captureCanvas = document.createElement('canvas');
            const captureCtx = captureCanvas.getContext('2d');
            const CAPTURE_SIZE = AI_INPUT_SIZE; // 480
            captureCanvas.width = CAPTURE_SIZE;
            captureCanvas.height = CAPTURE_SIZE;

            // üõ†Ô∏è NEW: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏ü‡∏•‡∏¥‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AI ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á
            if (currentFacingMode === 'user') {
                // ‡∏´‡∏≤‡∏Å‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤ ‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÉ‡∏´‡πâ AI ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ï‡∏£‡∏á
                captureCtx.translate(CAPTURE_SIZE, 0);
                captureCtx.scale(-1, 1);
            }
            
            // ‡∏ß‡∏≤‡∏î‡∏†‡∏≤‡∏û‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏•‡∏á Canvas ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á
            captureCtx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, CAPTURE_SIZE, CAPTURE_SIZE);
            
            // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï transform
            captureCtx.setTransform(1, 0, 0, 1, 0, 0);

            captureCanvas.toBlob(async (blob) => {
                if (!blob) return;

                const formData = new FormData();
                formData.append('file', blob, 'frame.jpg');

                statusElement.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...";
                
                const response = await fetch(API_URL, {
                    method: 'POST',
                    body: formData,
                });

                // ... (‡∏™‡πà‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Response)
                if (!response.ok) {
                    const errorText = await response.text();
                    statusElement.textContent = `‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î API: ‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ ${response.status} (Backend/ngrok ‡∏≠‡∏≤‡∏à‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà)`;
                    connectionStatusElement.textContent = `‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API: ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß! (${response.status})`;
                    console.error("HTTP Error from Backend:", response.status, errorText.substring(0, 100) + '...');
                    stopDetection();
                    return; 
                }

                let result;
                try {
                    result = await response.json();
                } catch (e) {
                    statusElement.textContent = `‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î API: ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà JSON (ngrok/Cloudflare Error?)`;
                    connectionStatusElement.textContent = `‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API: ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•`;
                    console.error("JSON Parsing Error:", e);
                    stopDetection();
                    return; 
                }

                let boxesData;
                let detectionCount;
                
                if (result.status === 'success') { 
                    const detectionsArray = result.detections;
                    if (detectionsArray && Array.isArray(detectionsArray)) {
                        boxesData = detectionsArray.map(d => ({
                            box: [d.box[0], d.box[1], d.box[2], d.box[3]], 
                            confidence: d.confidence,
                            class: d.class
                        }));
                        detectionCount = result.detections_count || boxesData.length;
                    } else {
                        boxesData = [];
                        detectionCount = 0;
                    }
                } else {
                    boxesData = [];
                    detectionCount = 0;
                }

                latestDetectionData = {
                    boxes: boxesData,
                    detections: detectionCount
                };
                
                updateHistory(boxesData);
                
                detectionCountElement.textContent = `‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö: ${detectionCount} ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏`;
                const processingTime = performance.now() - sendTime;
                statusElement.textContent = `‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! (Lat: ${processingTime.toFixed(0)}ms) - ${Math.round(1000/frameSendInterval)} FPS`;

            }, 'image/jpeg', 0.4); 

        } catch (error) {
            statusElement.textContent = `‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ`;
            connectionStatusElement.textContent = `‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ API: ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£`;
            console.error("Detection API Network Error:", error);
            
            isProcessing = false; 
            stopDetection();
        }
    }
    
    async function startDetectionProcess() {
        const isReady = await checkBackendConnectivity(); 
        if (isReady) {
            isProcessing = true;
            startCamera(currentFacingMode); 
        } else {
            isProcessing = false;
        }
    };

    startButton.onclick = startDetectionProcess;
    cameraSwitchButton.onclick = switchCamera; // üõ†Ô∏è NEW: ‡∏ú‡∏π‡∏Å‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á

    window.onload = async function() {
        statusElement.textContent = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö";
        await checkBackendConnectivity(); 
    };

    window.addEventListener('beforeunload', () => {
        stopDetection();
    });

    </script>
</body>
</html>